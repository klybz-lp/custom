<?php
	header("content-Type: text/html; charset=Utf-8");

	/* 正则表达式构成：
	 * 定界符号： 多种都可以， 常用为 // ，如||  () ##等
	 * 原子 : 最少的一个匹配单位 (放在定界符中), 在一个正则表达式中， 至少要有一个原子，如上例的a
	 * 元字符: 元字符不能单独使用的，修饰原子，  是用来扩展原子功能的和限定功能 (写在定界符号中)，如上例的{5}
	 * 模式修正符号:  修正， 对模式（正则）修正, （写在定界符号外面， 写在右边）如不区分大小写的i，全局g
	 *
	 * 原子：包括打印字符，即可以通过键盘打印出来的字符，如(a-z A-Z 0-9 !@#$%^&*()_+) 和非打印字符
	 * 具体分为5类：
	 * 1. 普通字符作为原子： 如 a~z、A~Z、0~9 等
	 * 2. 一些特殊字符和转义后元字符作为原子：
		所有标点符号，但语句特殊意义的符号需要转义后才可作为原子，如：\” \’ \* \+ \? \. 等
	 * 3. 一些非打印字符作为原子： 如：\f \n  \r \t \v \cx，即回车、换行、tab键等
	 * 4. 使用“通用字符类型”作为原子：如：\d \D \w \W \s \S。
	 * 5. 自定义原子表([])作为原子：如：’/[apj]sp/’ ’/[^apj]sp/’，[apj]
	 * 6.常用的“通用字符类型”
		\d	匹配任意一个十进制数字，等价于[0-9]
		\D	匹配任意一个除十进制数字以外的字符，等价于[^0-9]
		\s	匹配任意一个空白符，等价于[\f\n\r\t\v]
		\S	匹配除空白符以外任何字符，等价于[^\f\n\r\t\v]
		\w	匹配任意一个数字、字母或下画线，等价于[0-9a-zA-Z_]
		\W	匹配一个除数字、字母或下画线以外的任意一个字符，等价于[^0-9a-zA-Z_]
	 * 7.自己定义原子表,使用[]进行自定义，原子表是一表示匹配a或p或j
个区间范围，匹配其中任意一个即可
	 * 	[13579]    匹配数字1、3、5、7、9中的任意一个
	 * 	[^a-zA-Z]  -从哪到哪区间范围  ^除列表中的
	 * 8.点（.）代表原子中的任意一个
	 * 9.元字符： 不能在正则表达式中单独使用， 用来修饰原子的。 
		常见元字符：
	    *	匹配0次、1次或多次其前面的原子
		+	匹配1次或多次其前的原子
		？	匹配0次或1次其前的原子
		|	匹配两个或多个分支选择，注意该符号的优先级是最低的，如/ab|cd/,是匹配ab或者cd，而不是匹配b或者c
		{n}	表示其前面的原子恰好出现n次
		{n,}	表示其前面的原子出现不小于n次
		{n,m}	表示其前面的原子至少出现n次，最多出现m次
		^或\A	匹配输入字符串的开始位置（或在多行模式下行的开头，即紧随一个换行符之后）
		$或\Z	匹配输入字符串的结束位置（或在多行模式下行的结尾，即紧随一个换行符之前）
		\b	匹配单词的边界
		\B	匹配除单词边界以外的部分
		( )	匹配其整体为一个原子，即模式单元。可以理解为由多个单个原子组成的大原子
		小括号的第一个作用： 改变优先级别 
        小括号的第二个作用： 将小原子，变成大原子，即将多个单个原子变成一个整体去匹配
	 	小括号的第三个作用： 子模式, 整个表达式是一个大的模式， 小括号中是每个独立的子模式
	  	小括号的第四个作用： 反向引用，如\n表示引用正则表达式里第n个括号子表达式里匹配到的内容，双引号使用\\n
		可以使用{}自定义控制出现的字数，如：
		{m}  m = 3 用来修饰其前面原子只能出现 m次， 多一次和少一次都不可以
		{n,m} {2,5} 用来修饰其前面的原子出现个数在n到m之间，包括n和m
		{n,} {2,} 用来修饰其前面的原子可以出现至少n次
		{,m} {,5}   错误写法， 因为只有正的无穷大
		
	 * 10.模式修正符
		修正符写在定界符号外， 放在右边
		一个字符表示一个功能，可以组合使用
		i : 修正正则表达式不区分大小写（默认是区分大小写的）
		m : 修正符号修正正则表达式可以视为多行， 在使用 ^ 或 $ 这两个符号时， 每一行满足都可以。  （默认视为一行处理）
		s:  修正正则表达式中的 . 可以匹配换行符号 (默认 . 匹配任意字符除回车符号外)		
		x:  修正正则表达式，可以省略空白，如/web server/x  能匹配到/webserver/
		U:  (.*, .+) 这两种正则表达式比较贪婪,使用大写的U就能取消贪婪模式，但不推荐用，一般在+跟*后面加上?来取消贪婪   .*?  .+?
		
	 * 11.字符串操作函数/正则表达式函数：分割、匹配、查找、替换，如果可以使用字符串函数的就不用正则表达式，正则表达式函数功能强大但效率低，字符串查找的是固定的字符，正则表达式查找的一系列有规则的字符集
	 字符串匹配查找函数：
	 strstr  默认返回的是匹配到的位置一直到字符串的结束位置，如果传入第三个参数true，则返回匹配到的之前的字符串
	 strpos  返回的是匹配到的字符第一次出现位置，如果用来做判断要避免是查找第一个字符，因为位置为0，条件为假
	 strrpos查找一个字符最后一次出现的位置， stripos不区分大小写
	 substr  正则表达式匹配查找函数：preg_match()   preg_match_all()   preg_grep()匹配数组中的每个元素;
	 if(!preg_match("/^\S+$/",$_POST['username']))  匹配用户名不能为空，包括不能以空格开始或结尾，中间也不能出现空格
	 
	 字符串分割函数：explode()把字符串按指定字符分割成数组   implode() -- join()把数组的元素按指定元素合并
	 正则表达式：preg_split() 
	
	 替换    字符串处理  str_replace()     正则表达式  preg_replace()	
	 
	 
	 */
	$str = "aaaaaaa3aaaa5aaaa77777aaaaaaaaaaaaaaaaaaaa<br>";
	$reg = "/\d/";   //\d数字

	//echo preg_replace($reg, "#", $str)."<br>";  //把数组替换成#，第一个参数是匹配模式，第二个被替换后的内容，第三个是需要替换的字符串
	//print_r(preg_split($reg, $str));  //按数字分割字符串成数组，第一个参数是匹配模式，第二个是需要分割的字符串
	//preg_match正则表达式匹配函数，第一个参数是匹配模式，第二个参数需要操作的字符串，第三个可选参数是数组，会把匹配到的内容放到数组里，整个表达式匹配到的内容放到数组的第一个元素，如果使用了子模式即使用了()，则依次把子模式匹配到的结果放在后面，匹配到第一个符合模式的就退出，如果需要匹配所有的，用preg_match_all
	/*if(preg_match($reg, $str, $arr) ) {
		echo "正则表达式 <b>{$reg}</b> 和字符串 <b>{$str}</b> 匹配成功!<br>";
		print_r($arr);
	
	} else {
		echo "没有匹配上<br>";
	}*/
	
	
	//用()子模式，表示匹配完整个正则表达式后，把结果放到数组的第一个元素，然后再依次匹配带有()的子模式，把匹配到的结果发一次放入数组
	$url = "this  http://www.lampbrother.net  2014-01-24 oraclemysqlmysqlmysqlmysqllllllllllll is island";
	//$reg = "/http:\/\/www\..*\.net/";   //不使用子模式，结果是Array ( [0] => http://www.lampbrother.net )
	//使用子模式结果是Array ( [0] => http://www.lampbrother.net [1] => http [2] => www [3] => net )
	$reg = "/(http|https|ftp)\:\/\/(www|mail)\..*\.(net|com|cn|org)/";   
	/*if(preg_match($reg, $url, $arr) ) {
		echo "正则表达式 <b>{$reg}</b> 和字符串 <b>{$url}</b> 匹配成功!<br>";
		print_r($arr); 
	
	} else {
		echo "没有匹配上<br>";
	}*/
	
	//()的反向引用，即再次引用前面子模式的匹配模式，\n表示采用正则表达式里第n个括号里的子模式，注意双引号使用\\n，在使用替换函数的时候反向引用\n可以写成${n}
	$st = "this 2014-01-24 is island";
    //\1表示反向引用第一个子模式匹配到的内容，如(-|\/)匹配到的是-，则\1就是-，反之则是/，即两次出现的结果不行一致
	//$reg = '/\d{4}(-|\/)\d{2}\1\d{2}/'; 
	$reg = "/\d{4}(-|\/)\d{2}\\1\d{2}/";   //如果使用双引号，则必须写成\\1,因为双引号里\是转义字符
	//$reg = '/(?:\d{4})(-|\/)\d{2}\1\d{2}/';  //小括号里的?:是取消这个括号的子模式，不参与反向引用，没有使用则反向引用是\2

	/*if(preg_match($reg, $st, $arr)) {
		echo "正则 <b>{$reg}</b>, 和字符串<b>{$st}</b>匹配成功<br>";
		print_r($arr);
	} else {
		echo "匹配失败!<br>";
	}*/
	
	
	
	//贪婪匹配与取消贪婪匹配，(.*, .+) 这两种正则表达式比较贪婪
	$str = "this <b>is</b> a test  <b>Web</b> Serve";
	//$reg = '/\<b\>.*\<\/b\>/is';  //没取消贪婪模式,结果是is a test Web，一直匹配到第二个b标签结束的地方，
	$reg = '/\<b\>(.*?)\<\/b\>/is';  //取消了贪婪模式，结果是is web


	if(preg_match_all($reg, $str, $arr)) {
		echo "正则 <b>{$reg}</b>, 和字符串<b>{$str}</b>匹配成功<br>";
		print_r($arr);
	} else {
		echo "匹配失败!<br>";
	}

	//不用正则表达式跟系统的文件函数来获取文件名
	function getFileName($url) {
		$loc = strrpos($url, "/")+1;  //strrpos查找一个字符最后一次出现的位置
		return substr($url, $loc);
	}

	//echo getFileName("http://www.baidu.com/aaa/demo.php");
	
	
	//preg_grep匹配数组中的每个元素，形成一个新数组，常用来过滤数组元素，
	$arr = array("abcd1", "he llo2", "world", "ni hao");
	$content=preg_grep('/\d/', $arr);  //匹配数组中包含数字的元素
	//print_r($content);  //结果是Array ( [0] => abcd1 [1] => he llo2 )
	
	//字符串分割合并
	$arr=preg_split('//', $str, -1, PREG_SPLIT_NO_EMPTY);  //第三个可选参数是分割成的个数，-1则表示不限制，第四个参数是去掉空元素
	//echo implode("++++",$arr)."<br>";
	list($a, $b) = explode("_", "mei_zi");
	//echo $a."<br>";

	//字符串替换函数str_replace
	/*$num = 0;
	$str = "http://www.phpbrother.net/php/demo.php";
	$newstr = str_replace("php", "java", $str, $num); //第一个参数是需要替换的字符，第二个是替换后的字符，前面两个参数还可以是数组，第三个是替换的字符串，第四个可选参数是替换的次数，即字符串中包含了多少个需要替换的字符，需要使用第四个参数需要先定义一个变量
	echo $str."<br>";
	echo $newstr."<br>";
	echo "替换的次数为：{$num}<br>";*/
	
	/*$num = 0;
	//一次替换多个字符，正常  峰哥 妹子
	$str="这是一句正常的峰哥句子，妹子但里面有一些不能显示的文字";
	$newstr = str_replace(array("正常", "妹子", "峰哥"), "**", $str, $num);  //用一个数组表示需要被替换掉的内容
	//如果两个参数都是数组，需要一一对应
	//$newstr = str_replace(array("正常", "妹子", "峰哥"), array("很正常", "漂亮", "帅哥"), $str, $num);
	echo $str."<br>";
	echo $newstr."<br>";

	echo "替换的次数为：{$num}<br>";*/
	
	
	//正则表达式替换函数preg_replace()	
	$str ="如果http://www.baidu.com没有一些5特殊的<b>替换</b>需求（<u>比如正ftp://www.baidu.com则9表达式</u>），<1>你应</1>该使用http://www.baidu.cn该函数替换 <font color='red'>ereg_replace()</font> 和 preg_replace()。";

	/*$html = "/\<[\/\!]*?[^\<\>]*?\>/is";  //匹配字符串中所有的html标签，<>这两个符号都需要转义
	//html标记一般有<b>、</b>、<!---->,即/或!可以出现出现0次或多次，而且需要转义，然后使用?取消贪婪模式，即[\/\!]*?
	//<>里面的内容只要不是<>这两个尖括号就行，即[^\<\>]*?  ^不是非
	//i表示不区分大小写，s表示.可以匹配换行符号，[]是自己定义原子表
	$newstr = preg_replace($html, "", $str);
	echo $str."<br>";
	echo $newstr."<br>";
	
	//匹配字符串中所有的url,并加上超链接
	$href = "/(https?|ftps?):\/\/(www|mail|bbs|ftp)\.(.*?)\.(net|com|org|cn)([\w-\.\/\=\?\&\%]*)?/";
	$newstr1 = preg_replace($href,'<a href="\1://\2.\3.\4">\1://\2.\3.\4</a>', $str); 
	//使用子模式d的反向引用把匹配到的结果输出来，在preg_replace里\1可以使用$1,即第一个小括号子模式输出的结果
	//preg_replace函数使用e表示可以开启使用字符串函数
	echo $newstr1."<br>";*/

	//一次替换多个内容
	/*$reg  = array(
			'/\<[\/\!]*?[^\<\>]+?\>/is',  //html标记
			'/(https?|ftps?):\/\/(www|mail|bbs|ftp)\.(.*?)\.(net|com|org|cn)([\w-\.\/\=\?\&\%]*)?/e',  //url
			'/\d/'  //数字
		);

	$rep = array(
			'',
			'"<a href=\'$1://$2.$3.$4\'>".strtoupper("$1://$2.$3.$4")."</a>"',
			'@'
		);


	$newstr = preg_replace($reg, $rep, $str);*/
	
	
	//字符串比较函数
	$str1 = "abc";
	$str2 = "Abc";
	//strcmp返回0则表示两个字符相同，按字符个数一级ascii码进行比较，strcasecmp则不区分大小写
	switch(strcmp($str1, $str2)) {
		case 0:
			echo "第一个字符串$str1 等于 第二个字符串 $str2"; break;
		case -1:
			echo "第一个字符串$str1 小于 第二个字符串 $str2"; break;
		case 1:
			echo "第一个字符串$str1 大于 第二个字符串 $str2"; break;
	
	}

